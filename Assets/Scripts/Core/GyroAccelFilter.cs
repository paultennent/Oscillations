//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
public class GyroAccelFilter
{
	const float FILTER_CONSTANT = 0.995f;
	float lastAccZRaw = 0f;
	float lastAccZFilt = 0f;
	double lastProcessingTime = 0;
	float maxZSeen = 0;
	float maxZAngle = 0;

	float lastError=0;

	float currentGyroOffset=0;

	public GyroAccelFilter ()
	{
	}

	public void reset(float angle){
		currentGyroOffset = -angle;
	}

	public string debugMessage="";

	public float addValue (double time, float angle, float accZ)
	{
		//float retVal = 0;
		// high pass filter z acceleration
		float filteredAcc = (lastAccZFilt + accZ - lastAccZRaw) * FILTER_CONSTANT;
		debugMessage = "";
		if (filteredAcc > maxZSeen) {
			maxZSeen = filteredAcc;
			maxZAngle = angle+currentGyroOffset;
		}

		// look for zero crossing in z acceleration (and ignore two within 1 seconds)
		if (filteredAcc > 0 && lastAccZFilt < 0 && lastProcessingTime < time - 1) {
			lastProcessingTime = time;
			debugMessage="Zero crossing error:" + (maxZAngle+lastError)*0.5+" offset="+currentGyroOffset;
			lastError=maxZAngle;
			maxZAngle = 0;
			maxZSeen = 0;
			if(lastError<0)
			{
				currentGyroOffset +=0.5f;
			}else
			{
				currentGyroOffset -=0.5f;
			}
		}
		lastAccZRaw = accZ;
		lastAccZFilt = filteredAcc;
		return angle+currentGyroOffset;
	}

}

